import { SyncType, FileSyncType, FileSyncsType, MirrorSyncType } from './commonTypes';
import { runInDirectory } from './utils';

const consola = require('consola');
const crypto = require('crypto');
const fs = require('fs');
const YAML = require('yaml');
const { YAMLMap } = require('yaml');

Object.getPrototypeOf(YAMLMap).maxFlowStringSingleLineLength = 10000; // Stops yaml collections from wrapping

const setValueOnPath = (obj: any, path: string[], value: any) => {
  const last = path.pop();
  const parent = path.reduce((accum, p) => (accum[p]), obj);
  parent[last] = value;
};

const sha256 = (content: string) => crypto.createHash('sha256').update(content).digest('hex');

const jsonSync = (targetFileContents: string, fileSync: FileSyncType) => {
  const contents = JSON.parse(targetFileContents);

  const target = <string[]>fileSync.target;

  setValueOnPath(contents, target, fileSync.value);

  return JSON.stringify(contents, null, 2);
};

const yamlSync = (targetFileContents: string, fileSync: FileSyncType) => {
  const contents = YAML.parseDocument(targetFileContents).toJS();
  const target = <string[]>fileSync.target;

  setValueOnPath(contents, target, fileSync.value);

  return YAML.stringify(contents, { lineWidth: 0, minContentWidth: 0 });
};

const regexSync = (targetFileContents: string, fileSync: FileSyncType) => {
  const contents = targetFileContents.toString();

  const target = <string>fileSync.target;
  return contents.replace(new RegExp(target), fileSync.value);
};

const autoGeneratedIntro = '# This file is being modified by glue-ops. Do not edit manually.';
const synchronizationHashBase = '# Synchronization-Hash:';

// Removes the auto-generated comments from the file contents
const cleanContent = (fileContents: string): string => (
  fileContents.split('\n').slice(3).join('\n')
);

// Validates that the Synchronization-Hash in the target file matches the current file contents
const validateTargetFileHash = (fileContents: string) => {
  const hashCommentRegex = new RegExp(`${synchronizationHashBase} ([a-z0-9]+)`);
  const targetHash = fileContents.match(hashCommentRegex)[1];

  const valid = sha256(cleanContent(fileContents)) === targetHash;

  if (!valid) {
    consola.error('The target file has been modified and does not match it\'s Synchronization-Hash.');
    process.exit(1);
  }
};

const addAutogeneratedComments = (sourceContents: string): string => {
  const autogeneratedHash = `${synchronizationHashBase} ${sha256(sourceContents)}`;

  return `${autoGeneratedIntro}\n${autogeneratedHash}\n\n${sourceContents}`;
};

const mirrorSync = (targetFileContents: string, fileSync: MirrorSyncType) => {
  let sourceContents = '';

  if (fileSync.source.directory === 'rootProject') {
    runInDirectory(fileSync.source.directory, () => {
      sourceContents = fs.readFileSync(fileSync.source.path, 'utf8');
    });
  } else {
    sourceContents = fs.readFileSync(fileSync.source.path, 'utf8');
  }

  return addAutogeneratedComments(sourceContents);
};

export const runSync = (fileSync: SyncType, dryRun = false) => {
  fileSync.files.forEach((file) => {
    let syncedContents = '';
    let targetFileContents = '';

    if (fs.existsSync(file)) {
      targetFileContents = fs.readFileSync(file, 'utf8');
    }

    switch (fileSync.type) {
      case 'json':
        syncedContents = jsonSync(targetFileContents, fileSync);
        break;
      case 'yaml':
        syncedContents = yamlSync(targetFileContents, fileSync);
        break;
      case 'regex':
        syncedContents = regexSync(targetFileContents, fileSync);
        break;
      case 'mirror':
        syncedContents = mirrorSync(targetFileContents, fileSync);
        break;
      default:
        return consola.error('Unsupported file sync type');
    }

    if (fileSync.synchronizationHash) {
      if (targetFileContents.match(autoGeneratedIntro)) {
        validateTargetFileHash(targetFileContents);
      }

      if (syncedContents.match(autoGeneratedIntro)) {
        syncedContents = cleanContent(syncedContents);
      }

      syncedContents = addAutogeneratedComments(syncedContents);
    }

    if (dryRun) {
      console.log(syncedContents);
    } else {
      fs.writeFileSync(file, syncedContents);
    }
  });
};

export const runAllSyncs = (fileSyncs: FileSyncsType, dryRun = false) => {
  Object.keys(fileSyncs).forEach((fileSyncName) => {
    runSync(fileSyncs[fileSyncName], dryRun);
  });
};
