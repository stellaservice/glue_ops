import * as YAML from 'yaml';
import { YAMLMap } from 'yaml';
import { consola } from 'consola';
import * as fs from 'fs';

import {
  SyncType,
  FileSyncType,
  FileSyncsType,
  MirrorSyncType,
} from './commonTypes';
import { runInDirectory } from './utils';
import {
  addAutogeneratedComments,
  validateTargetFileHash,
} from './sync-hash';

Object.getPrototypeOf(YAMLMap).maxFlowStringSingleLineLength = 10000; // Stops yaml collections from wrapping

const setValueOnPath = (obj: any, path: string[], value: any) => {
  const last = path.pop();
  const parent = path.reduce((accum, p) => (accum[p]), obj);
  parent[last] = value;
};

const jsonSync = (targetFileContents: string, fileSync: FileSyncType) => {
  const contents = JSON.parse(targetFileContents);

  const target = <string[]>fileSync.target;

  setValueOnPath(contents, target, fileSync.value);

  return JSON.stringify(contents, null, 2);
};

const yamlSync = (targetFileContents: string, fileSync: FileSyncType) => {
  const contents = YAML.parseDocument(targetFileContents).toJS();
  const target = <string[]>fileSync.target;

  setValueOnPath(contents, target, fileSync.value);

  return YAML.stringify(contents, { lineWidth: 0, minContentWidth: 0 });
};

const regexSync = (targetFileContents: string, fileSync: FileSyncType) => {
  const contents = targetFileContents.toString();

  const target = <string>fileSync.target;
  return contents.replace(new RegExp(target), fileSync.value);
};

const mirrorSync = (fileSync: MirrorSyncType, sourceDirectory: string) => {
  let sourceContents = '';

  if (sourceDirectory !== '') {
    runInDirectory(sourceDirectory, () => {
      sourceContents = fs.readFileSync(fileSync.source.path, 'utf8');
    });
  } else {
    sourceContents = fs.readFileSync(fileSync.source.path, 'utf8');
  }

  return sourceContents;
};

export const runSync = (
  fileSync: SyncType,
  opts: { sourceDirectory?: string, dryRun?: boolean } = { sourceDirectory: '', dryRun: false },
) => {
  fileSync.files.forEach((file) => {
    let syncedContents = '';
    let targetFileContents = '';

    if (fs.existsSync(file)) {
      targetFileContents = fs.readFileSync(file, 'utf8');
    }

    switch (fileSync.type) {
      case 'json':
        syncedContents = jsonSync(targetFileContents, fileSync);
        break;
      case 'yaml':
        syncedContents = yamlSync(targetFileContents, fileSync);
        break;
      case 'regex':
        syncedContents = regexSync(targetFileContents, fileSync);
        break;
      case 'mirror':
        syncedContents = mirrorSync(fileSync, opts.sourceDirectory);
        break;
      default:
        return consola.error('Unsupported file sync type');
    }

    if (fileSync.synchronizationHash.enabled) {
      validateTargetFileHash(targetFileContents);
      const { commentSyntax } = fileSync.synchronizationHash;
      syncedContents = addAutogeneratedComments(syncedContents, commentSyntax);
    }

    if (opts.dryRun) {
      console.log(syncedContents);
    } else {
      fs.writeFileSync(file, syncedContents);
    }
  });
};

export const runAllSyncs = (fileSyncs: FileSyncsType, dryRun = false) => {
  Object.keys(fileSyncs).forEach((fileSyncName) => {
    runSync(fileSyncs[fileSyncName], { dryRun });
  });
};
